// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: RobotContainer.

package frc.robot;

import frc.robot.commands.*;
import frc.robot.subsystems.*;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.RunCommand;
import edu.wpi.first.wpilibj2.command.button.JoystickButton;

import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PS4Controller.Button;
import frc.robot.subsystems.*;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 * This class is where the bulk of the robot should be declared. Since
 * Command-based is a
 * "declarative" paradigm, very little robot logic should actually be handled in
 * the {@link Robot}
 * periodic methods (other than the scheduler calls). Instead, the structure of
 * the robot
 * (including subsystems, commands, and button mappings) should be declared
 * here.
 */
public class RobotContainer {

	private static RobotContainer m_robotContainer = new RobotContainer();

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	// The robot's subsystems
	public final Lifter m_lifter = new Lifter();
	public final Conveyor m_conveyor = new Conveyor();
	public final Cannon m_cannon = new Cannon();
	public final Intake m_intake = new Intake();
	public final Train m_train = new Train();

	// Joysticks
	private final Joystick joystick = new Joystick(0);

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// A chooser for autonomous commands
	SendableChooser<Command> m_chooser = new SendableChooser<>();


	/**
	 * The container for the robot. Contains subsystems, OI devices, and commands.
	 */
	private RobotContainer() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
		// Smartdashboard Subsystems

		// SmartDashboard Buttons
		SmartDashboard.putData("Autonomous Command", new AutonomousCommand());
		SmartDashboard.putData("Drive", new Drive(m_train));

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD

		// Configure the button bindings
		configureButtonBindings();

		// Configure default commands
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND

		// Configure autonomous sendable chooser
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

		m_chooser.setDefaultOption("Autonomous Command", new AutonomousCommand());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

		SmartDashboard.putData("Auto Mode", m_chooser);

		// Drives drivetrain based on joystick xy position
		m_train.setDefaultCommand(new RunCommand(() -> m_train.teleopDrive(joystick.getY(), joystick.getX()), m_train));
	}

	public static RobotContainer getInstance() {
		return m_robotContainer;
	}

	/**
	 * Use this method to define your button->command mappings. Buttons can be
	 * created by
	 * instantiating a {@link GenericHID} or one of its subclasses ({@link
	 * edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing
	 * it to a
	 * {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.
	 */
	private void configureButtonBindings() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
		// Create some buttons

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS

		// Initialize buttons
		final JoystickButton joystickButton1 = new JoystickButton(joystick, 1); // Conveyor Feed
		final JoystickButton joystickButton2 = new JoystickButton(joystick, 2); // Flywheel Spinup
		final JoystickButton joystickButton7 = new JoystickButton(joystick, 7); // Intake Eject
		final JoystickButton joystickButton8 = new JoystickButton(joystick, 8); // Intake Pull
		final JoystickButton joystickButton9 = new JoystickButton(joystick, 9); // Grabber Down
		final JoystickButton joystickButton10 = new JoystickButton(joystick, 10); // Grabber Up
		
		// Setup Cannon
		m_cannon.setDefaultCommand(new RunCommand(() -> {
			m_cannon.setThrottle(joystickButton2.get()? 1 - (joystick.getRawAxis(3) + 1)/2 : 0);
		}, m_cannon));

		// Setup Conveyor
		joystickButton1.whenPressed(() -> m_conveyor.feed());
		joystickButton1.whenReleased(() -> m_conveyor.stop());

		// Setup Intake
		joystickButton7.whenPressed(() -> m_intake.eject());
		joystickButton7.whenReleased(() -> m_intake.stop());
		joystickButton8.whenPressed(() -> m_intake.pull());
		joystickButton8.whenReleased(() -> m_intake.stop());

		// Setup Lifter
		joystickButton10.whenPressed(() -> m_lifter.extend());
		joystickButton10.whenReleased(() -> m_lifter.stop());
		joystickButton9.whenPressed(() -> m_lifter.retract());
		joystickButton9.whenReleased(() -> m_lifter.stop());
	}

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
	public Joystick getJoystick() {
		return joystick;
	}

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

	/**
	 * Use this to pass the autonomous command to the main {@link Robot} class.
	 *
	 * @return the command to run in autonomous
	 */
	public Command getAutonomousCommand() {
		// The selected command will be run in autonomous
		return m_chooser.getSelected();
	}

}
